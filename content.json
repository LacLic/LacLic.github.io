{"meta":{"title":"LacLic's Blog","subtitle":"Living with bustle, hearing of isolation.","description":"","author":"LacLic Vanilla","url":"http://laclic.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-11-29T06:38:30.000Z","updated":"2020-11-29T06:43:34.854Z","comments":true,"path":"tags/index.html","permalink":"http://laclic.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Ropewalkers","slug":"Ropewalkers","date":"2021-01-24T03:52:11.000Z","updated":"2021-01-24T04:28:48.589Z","comments":true,"path":"2021/01/24/Ropewalkers/","link":"","permalink":"http://laclic.github.io/2021/01/24/Ropewalkers/","excerpt":"","text":"题意：有3个人分别在一条平直的绳子（数轴）上的a,b,c处，3个人中，每秒只有一个人能移动，而且他/她/它(?)每次只能移动一格。问：经过多少秒，他们两两间距才会不小于d？ 12345678910111213141516171819202122232425262728293031// 让靠两边的人往外走即可#include &lt;cstdio&gt;inline void swap(int&amp; a,int&amp; b) &#123; a^=b^=a^=b;&#125;void sort(int&amp; min,int&amp; mid,int&amp; max) &#123; if(min&gt;mid) swap(min,mid); if(min&gt;max) swap(min,max); if(mid&gt;max) swap(mid,max);&#125;int main(int argc, char const *argv[])&#123; // 2,141,783,647 // 1,000,000,000 int a,b,c,d; long long ans=0; // maybe no need to use long long scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;d); sort(a,b,c); // now, a==min, b==mid, c==max int Dab = b-a, Dbc = c-b; // distance of a,b; distance of c,b if(Dab&lt;d) ans += d - Dab; if(Dbc&lt;d) ans += d - Dbc; printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://laclic.github.io/tags/codeforces/"},{"name":"sort","slug":"sort","permalink":"http://laclic.github.io/tags/sort/"}]},{"title":"Email from Polycarp","slug":"Email-from-Polycarp","date":"2021-01-24T03:51:51.000Z","updated":"2021-01-24T04:24:08.394Z","comments":true,"path":"2021/01/24/Email-from-Polycarp/","link":"","permalink":"http://laclic.github.io/2021/01/24/Email-from-Polycarp/","excerpt":"","text":"字符串问题题意：有一个键盘，打字的时候会失控，同一个字符打很多个出来，比如hello会打成heeeellllooo（YES情况），但是不会打成hell或者helo（NO情况）。输入给出了原文和失控后的文本，需要判断，失控后文本是否符合YES情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 逐字判断 --若字不同--&gt; 判断重复 --变为相同--&gt; 继续逐字判断 ----都到底了----&gt; YES!// --还是不同--&gt; NO！ --另一个没到底--&gt; NO!#include &lt;cstdio&gt;// #include &lt;iostream&gt;// using namespace std;char origin[1000006];char input[1000006];int main(int argc, char const *argv[])&#123; int n; scanf(&quot;%d&quot;,&amp;n); int mouse1, mouse2; for(;n;--n) &#123; int isTrue = 1; mouse1 = 0; mouse2 = 0; scanf(&quot;%s&quot;,origin); scanf(&quot;%s&quot;,input); while(origin[mouse1]!=&#x27;\\0&#x27;) &#123; if(origin[mouse1]==input[mouse2]) &#123; ++mouse1; ++mouse2; &#125;else &#123; if(mouse2&lt;1||input[mouse2-1]!=input[mouse2]) &#123; break; &#125; while(input[mouse2-1]==input[mouse2]) &#123; ++mouse2; &#125; &#125; if(origin[mouse1]!=&#x27;\\0&#x27;) printf(&quot;NO\\n&quot;); else &#123; while(origin[mouse1-1]==input[mouse2]) &#123; ++mouse2; &#125; if(input[mouse2]==&#x27;\\0&#x27;) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://laclic.github.io/tags/codeforces/"},{"name":"string","slug":"string","permalink":"http://laclic.github.io/tags/string/"}]},{"title":"Codeforce-Finding Sasuke","slug":"Codeforce-Finding-Sasuke","date":"2021-01-23T11:26:25.000Z","updated":"2021-01-24T01:02:26.210Z","comments":true,"path":"2021/01/23/Codeforce-Finding-Sasuke/","link":"","permalink":"http://laclic.github.io/2021/01/23/Codeforce-Finding-Sasuke/","excerpt":"","text":"思路存在性问题，只要找到一个通解即可我们选取每一对（2个）数，取相反数后交换位置相乘后必为0 e.g. there is A(a1) and B(a2), AB+B(-A) == 0, just let b1 = B, b2 = -A. 代码123456789101112131415161718192021#include &lt;cstdio&gt;int main(int argc, char const *argv[])&#123; int T,n; scanf(&quot;%d&quot;,&amp;T); for(;T;--T) &#123; scanf(&quot;%d&quot;,&amp;n); int temp1,temp2; for(int i=0;i&lt;n;i+=2) &#123; scanf(&quot;%d&quot;,&amp;temp1); scanf(&quot;%d&quot;,&amp;temp2); printf(&quot;%d &quot;,-temp2); printf(&quot;%d &quot;,temp1); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125;","categories":[],"tags":[{"name":"existence problem","slug":"existence-problem","permalink":"http://laclic.github.io/tags/existence-problem/"},{"name":"codeforces","slug":"codeforces","permalink":"http://laclic.github.io/tags/codeforces/"}]},{"title":"FZU2021-0x12-Prime Ring Problem","slug":"FZU2021-0x12-Prime-Ring-Problem","date":"2021-01-23T11:25:53.000Z","updated":"2021-01-23T11:40:26.956Z","comments":true,"path":"2021/01/23/FZU2021-0x12-Prime-Ring-Problem/","link":"","permalink":"http://laclic.github.io/2021/01/23/FZU2021-0x12-Prime-Ring-Problem/","excerpt":"","text":"Just do what the problem tell you to do. Take care of the format (I got a presentation error). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// brute force#include &lt;cstdio&gt;int status[23]; // to node whether a num is chosenint chosen[23];int n;int isPrime(int x) &#123; // prime table since the max of sum is 20+19=39 switch (x) &#123; case 2: case 3: case 5: case 7: case 11: case 13: case 17: case 19: case 23: case 29: case 31: case 37: case 41: return 1; default: return 0; &#125;&#125;void recur(const int&amp; now,const int&amp; layer) &#123; // recur is the abbr of &quot;recursion&quot; chosen[layer] = now; // just over-write it! if(layer==n) &#123; if(!isPrime(now+1)) return; // check whether the sum of 1st and last is prime printf(&quot;1&quot;); // print the first for(int i=2;i&lt;=n;++i) &#123; printf(&quot; %d&quot;,chosen[i]); &#125; printf(&quot;\\n&quot;); &#125;else &#123; for(int i=2;1;++i) &#123; for(;!status[i];++i); // skip chosen nums (whose status is 0) if(i&gt;n) break; // roop condition if(!isPrime(now+i)) continue; status[i] = 0; recur(i,layer+1); status[i] = 1; // restore the origin stage &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; for(int i=1;i&lt;=23;++i) &#123; status[i] = 1; &#125; int case_count = 0; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; ++case_count; printf(&quot;Case %d:\\n&quot;,case_count); recur(1,1); printf(&quot;\\n&quot;); &#125; return 0;&#125;","categories":[],"tags":[{"name":"FZUACM","slug":"FZUACM","permalink":"http://laclic.github.io/tags/FZUACM/"},{"name":"search","slug":"search","permalink":"http://laclic.github.io/tags/search/"},{"name":"brute force","slug":"brute-force","permalink":"http://laclic.github.io/tags/brute-force/"},{"name":"format","slug":"format","permalink":"http://laclic.github.io/tags/format/"}]},{"title":"FZU2021-0x11-Lake Counting","slug":"FZU2021-0x11-Lake-Counting","date":"2021-01-23T11:25:05.000Z","updated":"2021-01-23T11:38:46.813Z","comments":true,"path":"2021/01/23/FZU2021-0x11-Lake-Counting/","link":"","permalink":"http://laclic.github.io/2021/01/23/FZU2021-0x11-Lake-Counting/","excerpt":"","text":"idea：Just read the input,then fill the water(‘W’) with land(‘.’) one by one,the count of filling water times is the answer. 小 心 换 行 符 Be care of line-breaker code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;/*10 12....W....WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W.*/char a[106][106];const char b[8][2] = &#123;&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;&#125;;inline int fill(int x,int y) &#123; a[x][y] = &#x27;.&#x27;; for(int i=0;i&lt;8;++i) &#123; if(a[x+b[i][0]][y+b[i][1]]==&#x27;W&#x27;) &#123; fill(x+b[i][0],y+b[i][1]); &#125; &#125; return 1;&#125;int main(int argc, char const *argv[])&#123; int cnt=0; int N,M; scanf(&quot;%d %d&quot;,&amp;N,&amp;M); int M1 = M+1,N1 = N+1; int min = M&gt;N?N:M; for(int i=0;i&lt;=min;++i) &#123; a[i][0] = &#x27;.&#x27;; a[i][M1] = &#x27;.&#x27;; a[0][i] = &#x27;.&#x27;; a[N1][i] = &#x27;.&#x27;; &#125; for(int i=min+1;i&lt;=M;++i) &#123; a[0][i] = &#x27;.&#x27;; a[N1][i] = &#x27;.&#x27;; &#125; for(int i=min+1;i&lt;=N;++i) &#123; a[i][0] = &#x27;.&#x27;; a[i][M1] = &#x27;.&#x27;; &#125; a[N1][M1] = &#x27;.&#x27;; for(int i=1;i&lt;=N;++i) &#123; getchar(); // &lt;--- 读取换行符，刷新输入流 for(int j=1;j&lt;=M;++j) &#123; scanf(&quot;%c&quot;,&amp;a[i][j]); &#125; &#125; for(int i=1;i&lt;=N;++i) &#123; for(int j=1;j&lt;=M;++j) &#123; if(a[i][j]==&#x27;W&#x27;) cnt += fill(i,j); &#125; &#125; printf(&quot;%d&quot;,cnt); return 0;&#125;","categories":[],"tags":[{"name":"FZUACM","slug":"FZUACM","permalink":"http://laclic.github.io/tags/FZUACM/"},{"name":"search","slug":"search","permalink":"http://laclic.github.io/tags/search/"}]},{"title":"搭建vnt-chain开发测试网络（小白版）","slug":"搭建vnt-chain开发测试网络（小白版）","date":"2021-01-22T05:27:10.000Z","updated":"2021-01-22T11:54:39.894Z","comments":true,"path":"2021/01/22/搭建vnt-chain开发测试网络（小白版）/","link":"","permalink":"http://laclic.github.io/2021/01/22/%E6%90%AD%E5%BB%BAvnt-chain%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%EF%BC%88%E5%B0%8F%E7%99%BD%E7%89%88%EF%BC%89/","excerpt":"","text":"原文有些地方没讲清楚，有些坑不好绕（比如golang环境配置，gvnt环境变量添加等，这些都没讲，而且由于用的人少，百度谷歌都搜不到，我拉了一整个目录下来去找才知道gvnt怎么装），所以这边重新整理归纳一遍。 环境安装这个原文里完全没有这个步骤，百度也搜不到，找了好久 安装golang环境首先查看是否安装了golang环境 1&gt; go version 如果显示 1go version go1.13.8 linux/amd64 &lt;--- 如果有这句话，则说明你已经安装了golang，这步可以跳过啦~（不过可能要注意一下版本问题） 如果是 1234Command &#x27;go&#x27; not found, but can be installed with:apt install golang-go # version 2:1.13~1ubuntu2, orapt install gccgo-go # version 2:1.13~1ubuntu2 那我们进入下面的步骤手动安装： 1234# 创建文件夹并下载压缩包：mkdir golangcd golangwget https://golang.google.cn/dl/go1.15.7.linux-amd64.tar.gz 等待安装包下载完毕（是国内镜像，应该挺快） 解压 1tar -C /usr/local -zxvf go1.15.7.linux-amd64.tar.gz 将golang添加至环境变量先用vim编辑器打开环境变量文件vim /etc/profile大写状态下按下 L 将光标转移至最末尾小写状态下按下 i 进入插入模式在最后新建几行，添加 123export GOROOT=/usr/local/goexport GOPATH=/usr/local/go/bin/goexport PATH=$PATH:$GOROOT/bin 然后按esc，输入:wq，回车，写入并退出 接下来输入source /etc/profile重新载入一下 或者 用管理员身份打开powershell重启wsl 12net stop LxssManagernet start LxssManager 或者reboot重启虚拟机（wsl是无法重启的，只能用powershell关开） 然后go version检查一下是否安装并配置成功 12root@LacLic-S-LaPToP:~&#x2F;testnet# go versiongo version go1.13.8 linux&#x2F;amd64 &lt;--- 表示golang安装成功 安装go-vnt（gvnt）12mkdir -p &#x2F;src&#x2F;github.com&#x2F;vntchain&#x2F;cd &#x2F;src&#x2F;github.com&#x2F;vntchain&#x2F; 然后git clone https://github.com/vntchain/go-vnt克隆仓库 如果慢的话可以试试我拉取到gitee上的镜像 git clone https://gitee.com/LacLic/go-vnt 1cd go-vnt 如果有以前的版本，请更新到最新: git pull 然后，使用命令编译gvnt: make gvnt 或者使用命令编译gvnt和所有工具: make all 编译完成后，进入gvnt的bin文件夹 cd /src/github.com/vntchain/go-vnt/build/bin/ 运行gvnt./gvnt version，查看版本 1234567891011WARN [01-22|12:14:39] Sanitizing cache to Go&#x27;s GC limits provided=1024 updated=662GvntVersion: 0.6.4Git Commit: 298e779f11a2cab8da88ec9afaae756cf297463bArchitecture: amd64Protocol Versions: [63 62]Network Id: 1Go Version: go1.15.7Operating System: linuxGOPATH=/usr/local/go/bin/goGOROOT=/usr/local/go 至此，gvnt安装完成，我们将其添加至环境变量 老办法，vim /etc/profile打开环境变量配置文件，在最后添加一句 1export PATH=$PATH:/src/github.com/vntchain/go-vnt/build/bin 保存退出，忘了vim编辑器怎么用的话，回到上面再看一下，这里不再赘述（如果会用nano编辑器的话其实用nano也没问题） 接下来输入source /etc/profile重新载入一下 或者 用管理员身份打开powershell重启wsl 12net stop LxssManagernet start LxssManager 或者reboot重启虚拟机 此时运行gvnt version 同样回显了版本信息，至此，gvnt环境变量配置成功 搭建开发测试网络这里就和原文差不多了，只是集成一下命令，另外提醒一下注意的点 创建4个初始见证人的账号123cd ~mkdir testnetcd testnet 通过gvnt account new --datadir node0，建立node0节点，可以不用输入密码（直接按两下回车） 12345INFO [12-16|14:47:13] Maximum peer count VNT=25 LES=0 total=25Your new account is locked with a password. Please give a password. Do not forget this password.Passphrase:Repeat passphrase:Address: &#123;&quot;node0的address，先记录下来，后面有用&quot;&#125; 同理，现在请你再建立3个节点 123gvnt account new --datadir node1gvnt account new --datadir node2gvnt account new --datadir node3 输入tree .检查文件目录，大概是这样子的 12345678910111213.├── node0│ └── keystore│ └── UTC--2021-01-22T04-30-41.086197018Z--(这里是node0的地址)├── node1│ └── keystore│ └── UTC--2021-01-22T04-30-57.796677093Z--(这里是node1的地址)├── node2│ └── keystore│ └── UTC--2021-01-22T04-31-03.028884008Z--(这里是node2的地址)└── node3 └── keystore └── UTC--2021-01-22T04-31-07.940695653Z--(这里是node3的地址) 现在请要生成每个节点的p2p地址，我们分别分配端口号12340~12343gvnt --datadir node0 --port 12340 console启动后，输入admin.nodeInfo.vnode查看node0的p2p地址 12345&#x2F;&#x2F; 省略很多输出&gt; admin.nodeInfo.vnode ← 这是你的控制台输入&quot;&#x2F;ip4&#x2F;127.0.0.1&#x2F;tcp&#x2F;12340&#x2F;ipfs&#x2F;(一串字符))&quot;~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~这就是node0的p2p地址，请自行记录下来（不是记录这上面的），要记录你自己的机器上的 然后按ctrl+D退出 这时候node0目录下多了很多文件ls node0 12➜ ls node0gvnt history keystore vntdb vntdb文件夹下面保存了p2p地址，由于node0的p2p地址比较重要，我们需要将其备份cp node0/vntdb node0/vntdb.bk -r 其他三个如法炮制，用下面的命令分别启动后，控制台输入admin.nodeInfo.vnode获取p2p地址 123gvnt --datadir node1 --port 12341 consolegvnt --datadir node2 --port 12342 consolegvnt --datadir node3 --port 12343 console 接下来，移除节点0的临时数据gvnt目录: 1rm -rf node0&#x2F;gvnt 另外还要清理节点1，2，3的临时数据，否则使用配置文件初始化节点时会失败。 123rm -rf node1&#x2F;gvntrm -rf node2&#x2F;gvntrm -rf node3&#x2F;gvnt 创建创世块配置文件dpos.json我们可以直接直接拿仓库中的模板过来改 先把东西复制过来cp /src/github.com/vntchain/go-vnt/genesis_dpos.json dpos.json 然后vim dpos.json开始编辑文件，总共有8个地方需要改，已经全部用（括号形式）和 &lt;— here 标注 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; &quot;config&quot;: &#123; &quot;chainId&quot;: 1012, &quot;dpos&quot;: &#123; &quot;period&quot;: 2, &quot;witnessesNum&quot;: 4, &quot;witnessesUrl&quot;: [ &quot;（node0的p2p地址）&quot;, &lt;--- here1 &quot;（node1的p2p地址）&quot;, &lt;--- here2 &quot;（node2的p2p地址）&quot;, &lt;--- here3 &quot;（node3的p2p地址）&quot; &lt;--- here4 ] &#125; &#125;, &quot;timestamp&quot;: &quot;0x5c2a3d00&quot;, &quot;extraData&quot;: &quot;0x&quot;, &quot;gasLimit&quot;: &quot;0x47b760&quot;, &quot;difficulty&quot;: &quot;0x1&quot;, &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;, &quot;alloc&quot;: &#123; &quot;0x122369f04f32269598789998de33e3d56e2c507a&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125;, &quot;0x3dcf0b3787c31b2bdf62d5bc9128a79c2bb18829&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125;, &quot;0x42a875ac43f2b4e6d17f54d288071f5952bf8911&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125;, &quot;0xbf66d398226f200467cd27b14e85b25a8c232384&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125;, &quot;0x491f4e8d914e30b1a5e8c804789094fe30971807&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125;, &quot;0xe23f3ed4b6969f29284f667c16761212678c917d&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125; &#125;, &quot;witnesses&quot;: [ &quot;（node0的address）&quot;, &lt;--- here5 &quot;（node1的address）&quot;, &lt;--- here6 &quot;（node2的address）&quot;, &lt;--- here7 &quot;（node3的address）&quot; &lt;--- here8 ], &quot;number&quot;: &quot;0x0&quot;, &quot;gasUsed&quot;: &quot;0x0&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&#125; 别写反了，最后大概会是这个样子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; &quot;config&quot;: &#123; &quot;chainId&quot;: 1012, &quot;dpos&quot;: &#123; &quot;period&quot;: 2, &quot;witnessesNum&quot;: 4, &quot;witnessesUrl&quot;: [ &quot;/ip4/127.0.0.1/tcp/12340/ipfs/1kHcch6yuBCgC5nPPSK3Yp7Es4c4eenxAeK167pYwUvNjRo&quot;, &quot;/ip4/127.0.0.1/tcp/12341/ipfs/1kHJFKr2bzUnMr1NbeyYbYJa3RXT18cEu7cNDrHWjg8XYKB&quot;, &quot;/ip4/127.0.0.1/tcp/12342/ipfs/1kHfop9dnUHHmtBXVkLB5UauAmACtrsEX5H5t6oCRpdL198&quot;, &quot;/ip4/127.0.0.1/tcp/12343/ipfs/1kHHWuQNUVV2wgE8SqzQjWhiFQcfpkP5tRVTdJXAPWVj4nR&quot; ] &#125; &#125;, &quot;nonce&quot;: &quot;0x0&quot;, &quot;timestamp&quot;: &quot;0x5b45b949&quot;, &quot;extraData&quot;: &quot;0x&quot;, &quot;gasLimit&quot;: &quot;0x47b760&quot;, &quot;difficulty&quot;: &quot;0x1&quot;, &quot;mixHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;, &quot;alloc&quot;: &#123; &quot;0x122369f04f32269598789998de33e3d56e2c507a&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125;, &quot;0x3dcf0b3787c31b2bdf62d5bc9128a79c2bb18829&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125;, &quot;0x42a875ac43f2b4e6d17f54d288071f5952bf8911&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125;, &quot;0xbf66d398226f200467cd27b14e85b25a8c232384&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125;, &quot;0x491f4e8d914e30b1a5e8c804789094fe30971807&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125;, &quot;0xe23f3ed4b6969f29284f667c16761212678c917d&quot;: &#123; &quot;balance&quot;: &quot;0x200000000000000000000000000000000000000000000000000000000000000&quot; &#125; &#125;, &quot;witnesses&quot;: [ &quot;0xf31a08c03e03e36214f737755c235e6eadc5502e&quot;, &quot;0x9689e062952b71b825cd9dfc1d1d01a6319c6ebc&quot;, &quot;0x54604da2bad12b66e9aef6b8c04629b68771778e&quot;, &quot;0xe3d4f3e7d1b82dcc210efe1e0666b45e5a619a2d&quot; ], &quot;number&quot;: &quot;0x0&quot;, &quot;gasUsed&quot;: &quot;0x0&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&#125; 经过以上操作后，查看testnet tree . -L 2testnet的目录应当如下： 12345678910111213141516171819➜ testnet tree . -L 2.├── dpos.json├── node0│ ├── history│ ├── keystore│ └── vntdb├── node1│ ├── history│ ├── keystore│ └── vntdb├── node2│ ├── history│ ├── keystore│ └── vntdb└── node3 ├── history ├── keystore └── vntdb 启动节点这里原文没详细讲怎么同时运行，我用的screen来同时部署运行的 启动0节点（bootnode）12screen -S node0gvnt --networkid 1012 --datadir node0 --port 12340 console 注意不要ctrl+D关闭了，我们直接关闭wsl-ubuntu(shell)窗口就好，screen窗口会在后台持续运行，不会随着关闭shell窗口而停止 启动剩余节点重新打开ubuntu，输入cd testnet，进入测试网目录，剩下的如法炮制 123456screen -S node1gvnt --networkid 1012 --datadir node1 --port 12341 --vntbootnode &quot;（这里填入是node0的p2p地址，不是node1&#x2F;2&#x2F;3）&quot; consolescreen -S node2gvnt --networkid 1012 --datadir node2 --port 12342 --vntbootnode &quot;（这里填入是node0的p2p地址，不是node1&#x2F;2&#x2F;3）&quot; consolescreen -S node3gvnt --networkid 1012 --datadir node3 --port 12343 --vntbootnode &quot;（这里填入是node0的p2p地址，不是node1&#x2F;2&#x2F;3）&quot; console 之后如果想回到控制页面的话，只要screen -r node0/1/2/3回到相应screen就好了 节点3上的peer信息如下，各节点上都会有3个节点，说明我们的测试网络已经搭建起来了：大概会是这样的（id什么的有不同很正常） 1234567891011121314151617181920212223242526272829303132333435363738&gt; admin.peers[&#123; caps: null, id: &quot;&lt;peer.ID 1kHJFKr2bzUnMr1NbeyYbYJa3RXT18cEu7cNDrHWjg8XYKB&gt;&quot;, name: &quot;&quot;, network: &#123; inbound: false, localAddress: &quot;/ip4/127.0.0.1/tcp/12343&quot;, remoteAddress: &quot;/ip4/127.0.0.1/tcp/12341&quot;, static: false, trusted: false &#125;, protocols: null&#125;, &#123; caps: null, id: &quot;&lt;peer.ID 1kHcch6yuBCgC5nPPSK3Yp7Es4c4eenxAeK167pYwUvNjRo&gt;&quot;, name: &quot;&quot;, network: &#123; inbound: false, localAddress: &quot;/ip4/127.0.0.1/tcp/12343&quot;, remoteAddress: &quot;/ip4/127.0.0.1/tcp/12340&quot;, static: false, trusted: false &#125;, protocols: null&#125;, &#123; caps: null, id: &quot;&lt;peer.ID 1kHfop9dnUHHmtBXVkLB5UauAmACtrsEX5H5t6oCRpdL198&gt;&quot;, name: &quot;&quot;, network: &#123; inbound: false, localAddress: &quot;/ip4/127.0.0.1/tcp/12343&quot;, remoteAddress: &quot;/ip4/127.0.0.1/tcp/12342&quot;, static: false, trusted: false &#125;, protocols: null&#125;] 打包区块在每个初始见证人节点上解锁账户、开启共识，可以看到区块不断产生。 12personal.unlockAccount(core.coinbase, &quot;账户密码&quot;, 3153600000) &#x2F;&#x2F; 3153600000指解锁的秒数，这段时间之后，账户会自动锁住bp.start() 以上，开发测试网络就搭建起来了。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://laclic.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://laclic.github.io/tags/ubuntu/"},{"name":"shell","slug":"shell","permalink":"http://laclic.github.io/tags/shell/"},{"name":"vnt-chain","slug":"vnt-chain","permalink":"http://laclic.github.io/tags/vnt-chain/"},{"name":"block chain","slug":"block-chain","permalink":"http://laclic.github.io/tags/block-chain/"}]},{"title":"FZU2021-0x03-Boxes in a Line","slug":"FZU2021-0x03-Boxes-in-a-Line","date":"2021-01-21T09:51:41.000Z","updated":"2021-01-21T12:40:43.347Z","comments":true,"path":"2021/01/21/FZU2021-0x03-Boxes-in-a-Line/","link":"","permalink":"http://laclic.github.io/2021/01/21/FZU2021-0x03-Boxes-in-a-Line/","excerpt":"","text":"Use two array to simulate doubly linked listTake care of side-to-side swapWatch out reverseCommand 1 (when reversed) is equal to command 2 (when normally ordered),command 2 (when reversed) is in a similar way. Command 3 is the same whether it is reversed. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// doubly linked list#include &lt;cstdio&gt;#include &lt;cstdlib&gt;/*6 41 1 42 3 53 1 646 31 1 42 3 53 1 6100000 14*/int left[100006];int right[100006];int case_count = 0;int reverse;int cmd;inline void link(const int &amp;L, const int &amp;R) &#123; right[L] = R; left[R] = L;&#125;void prt(const int &amp;reverse, const int max) &#123; int now = max * reverse; // if reversed, now starts at max, otherwise at 0; long long sum = 0; int shouldAdd = 1; switch (reverse) &#123; case 0: &#123; for (now = right[now]; now%max; now = right[now]) &#123; if (shouldAdd%2) &#123; sum += now; &#125; ++shouldAdd; &#125; break; &#125; case 1: &#123; for (now = left[now]; now; now = left[now]) &#123; if (shouldAdd%2) &#123; sum += now; &#125; ++shouldAdd; &#125; break; &#125; &#125; printf(&quot;Case %d: %lld\\n&quot;, case_count, sum);&#125;int main(int argc, char const *argv[]) &#123; int n, m; while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF) &#123; reverse = 0; ++case_count; for (int i = 1; i &lt;= n; ++i) &#123; left[i] = i - 1; right[i] = i + 1; &#125; right[0] = 1; left[n + 1] = n; // printf(&quot;pwn! %d\\n&quot;,m); for (; m; --m) &#123; scanf(&quot;%d&quot;,&amp;cmd); // printf(&quot;pwn! %d\\n&quot;,m); switch (cmd) &#123; case 4: reverse = !reverse; break; default: &#123; int first, second; scanf(&quot;%d %d&quot;, &amp;first, &amp;second); if(reverse) cmd = 3-cmd; if(left[second]==first&amp;&amp;cmd==1) &#123;continue;&#125; if(right[second]==first&amp;&amp;cmd==2) &#123;continue;&#125; int L1 = left[first], R1 = right[first], L2 = left[second], R2 = right[second]; switch (cmd) &#123; case 0: case 3: if(right[first]==second) &#123; link(L1,second); link(second,first); link(first,R2); &#125;else if (left[first]==second) &#123; link(L2,first); link(first,second); link(second,R1); &#125;else &#123; link(L1, second); link(second, R1); link(L2, first); link(first, R2); &#125; continue; case 1: link(L1, R1); link(L2, first); link(first, second); continue; case 2: link(L1, R1); link(second, first); link(first, R2); continue; &#125; &#125; &#125; &#125; // for(int i=right[0];i%7;i=right[i]) &#123; // printf(&quot;%d &quot;,i); // &#125; prt(reverse, n + 1); &#125; return 0;&#125;","categories":[],"tags":[{"name":"FZUACM","slug":"FZUACM","permalink":"http://laclic.github.io/tags/FZUACM/"},{"name":"linked list","slug":"linked-list","permalink":"http://laclic.github.io/tags/linked-list/"},{"name":"array list","slug":"array-list","permalink":"http://laclic.github.io/tags/array-list/"}]},{"title":"安装 wsl2-ubuntu","slug":"wsl2-ubuntu","date":"2021-01-21T09:49:27.000Z","updated":"2021-01-22T05:28:17.864Z","comments":true,"path":"2021/01/21/wsl2-ubuntu/","link":"","permalink":"http://laclic.github.io/2021/01/21/wsl2-ubuntu/","excerpt":"","text":"为了搭建临时测试网络，我们需要linux环境，ubuntu是一个比较易上手的linux发行版 官方教程：https://docs.microsoft.com/zh-cn/windows/wsl/install-win10 以下是我自己电脑安装wsl2-ubuntu的过程（比较简单，但是可能有些设置是不一样的，比如我这个win10的wsl是默认开启的，还有win10版本是默认最新的，有问题可以直接来找我） 前言为何需要使用 linux因为很多教程命令都是基于linux系统撰写的，也为了防止由于系统版本问题而产生与教程结果不一致的问题 为何使用 wsl2(windows-subsystem-linux 2)因为方便好装（win10商店就有），而且不用安装双系统天天重启切换，并且性能比虚拟机好（如果已经有虚拟机，嫌麻烦其实不用装wsl也可以） 另外，wsl2还有很多好用的功能，在这里就不列举了（因为我也没体会过），就作个引用好了。原文. 为什么要升级到WSL2用过 WSL 第一代的朋友一定都遇到过一些比较蛋疼兼容性的问题，这些问题是由于 WSL 并不“完整”导致的。说到底 WSL 还只是一个用于访问 Linux 环境的兼容层，并没有实现 Linux 内核的完整功能。比如，我遇到了这些情况：· 无法启动Go的 Debug 进程，导致调试Go程序很麻烦· 需要在 WSL 下单独安装一套 Docker 引擎，并进行额外配置· 在 WSL 下启动 VS Code 后，会出现目录中文件被占用的情况，导致无法重命名，必须要先退出 VS Code· 无法正常使用 Linux 下全部命令，比如netstat而 WSL2 基于Hyper-V功能的子集提供了“真正的 Linux 内核”，因此上述问题也被解决了。同时，WSL2 也 支持 Windows 10 家庭版，因此之前家庭版不能用 Docker Desktop 的情况也已经成了历史。 这对于习惯使用 Linux 开发，但是又需要 Windows 玩游戏，同时不希望用盗版的有志青年们来说简直是天大的福音。 使用教程下载与安装单击你的win键（没有输入框，但是你可以试试随便按一个字幕/数字键，会自动切换到搜索输入框），输入Microsoft store（如果你经常用的话，输入个M可能就能出来了） 搜索ubuntu（无需穿墙），下载安装（免费）三个版本其实都可以 此时，单击win键输入ubuntu，点击即可打开 打开后，什么都没有，嗯也可能会显示版本信息，一天显示一次现在我们处于欢迎视窗（刚进wsl-ubuntu时候就会打开的东西，我也不知道有什么用，反正挺迷惑的）需要我们自行退出 键盘进行ctrl+C，退出欢迎视窗 然后你就可以关掉了，因为现在装的是wsl1，我们需要升级wsl2 升级 wsl2单击win，输入powershell，右键一个蓝蓝的东西Microsoft Powershell（别开PowerPoint去了），点击以管理员身份运行（一定要是这样开！！不然后面会报错的！） 输入 1wsl --set-default-version 2 会提示你安装wsl2内核，按照提示安装即可 （或者试试下面这条命令，请注意，一定要以管理员身份打开powershell） 1dism.exe &#x2F;online &#x2F;enable-feature &#x2F;featurename:VirtualMachinePlatform &#x2F;all &#x2F;norestart 然后再来 1wsl --set-default-version 2 最后输入wsl --list --verbose检查一下确实是装上了wsl2-ubuntu","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://laclic.github.io/tags/linux/"},{"name":"wsl","slug":"wsl","permalink":"http://laclic.github.io/tags/wsl/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://laclic.github.io/tags/ubuntu/"},{"name":"shell","slug":"shell","permalink":"http://laclic.github.io/tags/shell/"}]},{"title":"FZU2021-0x05-Train Problem I","slug":"FZU2021-0x05-Train-Problem-I","date":"2021-01-20T06:41:01.000Z","updated":"2021-01-20T06:46:44.049Z","comments":true,"path":"2021/01/20/FZU2021-0x05-Train-Problem-I/","link":"","permalink":"http://laclic.github.io/2021/01/20/FZU2021-0x05-Train-Problem-I/","excerpt":"","text":"同样是消消乐12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// use stack#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#define TOTAL 10using namespace std;char cmd[18] = &#123;0&#125;; // 1: IN, 2: OUT, 0: endchar now_at = 0; // to point out where to push the next cmdinline void cmd_push(int command) &#123; cmd[now_at] = command; ++now_at;&#125;// inline void clear(stack&lt;char&gt;&amp;thiz) &#123; // no need to initialize it, when one problem is over, because stack will be disposed before going to the next roop// stack&lt;char&gt; empty;// swap(thiz,empty);// &#125;int main(int argc, char const *argv[])&#123; int N; char in[TOTAL],out[TOTAL]; while(scanf(&quot;%d&quot;,&amp;N)!=EOF) &#123; stack&lt;char&gt; stk; scanf(&quot;%s %s&quot;,in,out); int mouse[3] = &#123;0&#125;; // 1: in, 2: out, 0: of no use while(mouse[1]&lt;N) &#123; if(in[mouse[1]]==out[mouse[2]]) &#123; ++mouse[1]; ++mouse[2]; cmd_push(1); cmd_push(2); while(!stk.empty()&amp;&amp;stk.top()==out[mouse[2]]) &#123; ++mouse[2]; stk.pop(); cmd_push(2); &#125; &#125;else &#123; stk.push(in[mouse[1]]); ++mouse[1]; cmd_push(1); &#125; &#125; cmd[now_at] = 0; if(!stk.empty()) printf(&quot;No.\\n&quot;); else &#123; printf(&quot;Yes.\\n&quot;); // print the content in cmd[] for(int i=0;cmd[i]!=0;++i) &#123; switch (cmd[i]) &#123; case 1: printf(&quot;in\\n&quot;); break; case 2: printf(&quot;out\\n&quot;); break; &#125; &#125; &#125; printf(&quot;FINISH\\n&quot;); // reset now_at now_at = 0; &#125; return 0;&#125;","categories":[],"tags":[{"name":"FZUACM","slug":"FZUACM","permalink":"http://laclic.github.io/tags/FZUACM/"},{"name":"c++","slug":"c","permalink":"http://laclic.github.io/tags/c/"},{"name":"stack","slug":"stack","permalink":"http://laclic.github.io/tags/stack/"}]},{"title":"FZU2021-0x06-看病要排队","slug":"FZU2021-0x06-看病要排队","date":"2021-01-20T03:26:14.000Z","updated":"2021-01-20T03:41:18.889Z","comments":true,"path":"2021/01/20/FZU2021-0x06-看病要排队/","link":"","permalink":"http://laclic.github.io/2021/01/20/FZU2021-0x06-%E7%9C%8B%E7%97%85%E8%A6%81%E6%8E%92%E9%98%9F/","excerpt":"","text":"Remain&emsp; Cause error if using Class Patient with reload operator&lt;, WHY?123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// priority_queue// need to clear queue before new problem comes#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;// class Patient &#123;// public:// int id;// int prior;// bool operator &lt; (const Patient other) &#123;// if(this-&gt;prior == other.prior) return this-&gt;id &gt; other.id;// else return this-&gt;prior &lt; other.prior;// &#125;// &#125;typedef struct _patient&#123; int id; int prior;&#125;Patient; bool operator &lt; (const Patient&amp;thiz,const Patient other) &#123; if(thiz.prior == other.prior) return thiz.id &gt; other.id; else return thiz.prior &lt; other.prior;&#125;void clear(priority_queue&lt;Patient&gt; &amp;target) &#123; priority_queue&lt;Patient&gt; empty; target.swap(empty);&#125;int main(int argc, char const *argv[])&#123; int N,doctor,prior; char cmd[4]; while(scanf(&quot;%d&quot;,&amp;N)!=EOF) &#123; priority_queue&lt;Patient&gt; que[4]; int i=1; for(;N;--N) &#123; scanf(&quot;%s&quot;,cmd); if(cmd[0]==&#x27;I&#x27;) &#123; scanf(&quot;%d %d&quot;,&amp;doctor,&amp;prior); Patient temp = &#123;i,prior&#125;; que[doctor].push(temp); ++i; &#125;else &#123; scanf(&quot;%d&quot;,&amp;doctor); if(que[doctor].empty()) printf(&quot;EMPTY\\n&quot;); else &#123; printf(&quot;%d\\n&quot;,que[doctor].top().id); que[doctor].pop(); &#125; &#125; &#125; for(int i=1;i&lt;4;++i) &#123; clear(que[i]); &#125; &#125; return 0;&#125;/*7IN 1 1IN 1 2OUT 1OUT 2IN 2 1OUT 2OUT 12IN 1 1OUT 18IN 1 1IN 1 1IN 1 1IN 1 1OUT 1OUT 1OUT 1OUT 1*/","categories":[],"tags":[{"name":"FZUACM","slug":"FZUACM","permalink":"http://laclic.github.io/tags/FZUACM/"},{"name":"c++","slug":"c","permalink":"http://laclic.github.io/tags/c/"},{"name":"priority_queue","slug":"priority-queue","permalink":"http://laclic.github.io/tags/priority-queue/"}]},{"title":"FZU2021-0x04-Replace To Make Regular Bracket Sequence","slug":"FZU2021-0x04-Replace-To-Make-Regular-Bracket-Sequence","date":"2021-01-20T03:25:55.000Z","updated":"2021-01-20T03:41:47.896Z","comments":true,"path":"2021/01/20/FZU2021-0x04-Replace-To-Make-Regular-Bracket-Sequence/","link":"","permalink":"http://laclic.github.io/2021/01/20/FZU2021-0x04-Replace-To-Make-Regular-Bracket-Sequence/","excerpt":"","text":"消消乐12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Use stack#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;char s[1000006];// &lt; &gt;, &#123; &#125;, [ ], ( ).// 0 4 1 5 2 6 3 7inline char table(char ch) &#123; switch (ch) &#123; case &#x27;&lt;&#x27;: return 0; case &#x27;&#123;&#x27;: return 1; case &#x27;[&#x27;: return 2; case &#x27;(&#x27;: return 3; case &#x27;&gt;&#x27;: return 4; case &#x27;&#125;&#x27;: return 5; case &#x27;]&#x27;: return 6; case &#x27;)&#x27;: return 7; &#125; return -1;&#125;int main(int argc, char const *argv[])&#123; int cnt = 0; while(scanf(&quot;%s&quot;,s)!=EOF) &#123; stack&lt;char&gt; stk; int impossible = 0; for(int i=0;s[i]!=&#x27;\\0&#x27;;++i) &#123; int temp = table(s[i]); if(temp&gt;=4) &#123; if(stk.empty()) &#123; impossible = 1; break; &#125; if(temp - stk.top()==4) &#123; stk.pop(); &#125;else &#123; stk.pop(); ++cnt; &#125; &#125;else &#123; stk.push(temp); &#125; &#125; if(!stk.empty()) impossible=1; if(impossible) &#123; printf(&quot;Impossible\\n&quot;); &#125;else &#123; printf(&quot;%d\\n&quot;,cnt); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"FZUACM","slug":"FZUACM","permalink":"http://laclic.github.io/tags/FZUACM/"},{"name":"c++","slug":"c","permalink":"http://laclic.github.io/tags/c/"},{"name":"stack","slug":"stack","permalink":"http://laclic.github.io/tags/stack/"}]},{"title":"FZU2021-0x02-Broken Keyboard (a.k.a. Beiju Text)","slug":"FZU2021-0x02-Broken-Keyboard-a-k-a-Beiju-Text","date":"2021-01-20T03:25:21.000Z","updated":"2021-01-20T03:41:43.274Z","comments":true,"path":"2021/01/20/FZU2021-0x02-Broken-Keyboard-a-k-a-Beiju-Text/","link":"","permalink":"http://laclic.github.io/2021/01/20/FZU2021-0x02-Broken-Keyboard-a-k-a-Beiju-Text/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;char s[100007];int main(int argc, char const *argv[])&#123; while(scanf(&quot;%s&quot;,s)==1) &#123; deque&lt;char*&gt; v; v.push_back(s); int i; for(i=0;s[i]!=&#x27;\\0&#x27;;++i) &#123; if(s[i]==&#x27;[&#x27;) &#123; s[i] = &#x27;\\0&#x27;; v.push_front(s+i+1); &#125; if(s[i]==&#x27;]&#x27;) &#123; s[i] = &#x27;\\0&#x27;; v.push_back(s+i+1); &#125; &#125; s[i] = &#x27;\\0&#x27;; s[i+1] = &#x27;\\0&#x27;; // int len = v.size(); // for(i=0;i&lt;len;++i) &#123; // printf(&quot;%s&quot;,v[i]); // &#125; for(deque&lt;char*&gt;::iterator it=v.begin();it!=v.end();++it) &#123; printf(&quot;%s&quot;,*it); &#125; printf(&quot;\\n&quot;); // printf(&quot;#&quot;); &#125; return 0;&#125;","categories":[],"tags":[{"name":"FZUACM","slug":"FZUACM","permalink":"http://laclic.github.io/tags/FZUACM/"},{"name":"c++","slug":"c","permalink":"http://laclic.github.io/tags/c/"},{"name":"string and point","slug":"string-and-point","permalink":"http://laclic.github.io/tags/string-and-point/"},{"name":"deque","slug":"deque","permalink":"http://laclic.github.io/tags/deque/"}]},{"title":"FZU2021-0x01-小孩报数问题","slug":"FZU2021-0x01-小孩报数问题","date":"2021-01-20T03:24:51.000Z","updated":"2021-01-20T03:41:36.944Z","comments":true,"path":"2021/01/20/FZU2021-0x01-小孩报数问题/","link":"","permalink":"http://laclic.github.io/2021/01/20/FZU2021-0x01-%E5%B0%8F%E5%AD%A9%E6%8A%A5%E6%95%B0%E9%97%AE%E9%A2%98/","excerpt":"","text":"Take care of how the end comes back to the begin1234567891011121314151617181920212223242526272829303132333435363738394041424344/* circle problem */// take care of how the end comes back to the begin#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[])&#123; int N,W,S; scanf(&quot;%d&quot;,&amp;N); vector&lt;string&gt; v; string temp; for(;N;--N) &#123; cin &gt;&gt; temp; v.push_back(temp); &#125; scanf(&quot;%d,%d&quot;,&amp;W,&amp;S); // int len = v.size(); // for(int i=0;i&lt;len;++i) &#123; // debug // printf(&quot;%s\\n&quot;,&amp;v[i][0]); // &#125; // vector&lt;string&gt;::iterator it = v.begin(); int cnt = 1; int lenth = v.size(); for(int now=W-1;!v.empty();++now) &#123; lenth = v.size(); int SS = S % lenth; if(SS == 0) SS = lenth; if(SS == 1) SS += lenth; if(now &gt;= lenth) now %= lenth; if(cnt==SS) &#123; printf(&quot;%s\\n&quot;,&amp;v[now][0]); v.erase(v.begin()+now); cnt = 1; &#125; ++cnt; &#125; return 0;&#125;","categories":[],"tags":[{"name":"FZUACM","slug":"FZUACM","permalink":"http://laclic.github.io/tags/FZUACM/"},{"name":"circle","slug":"circle","permalink":"http://laclic.github.io/tags/circle/"},{"name":"c++","slug":"c","permalink":"http://laclic.github.io/tags/c/"}]},{"title":"spider get ajax and frame page","slug":"spider-get-ajax-and-frame-page","date":"2020-12-30T09:54:10.000Z","updated":"2020-12-30T11:15:02.919Z","comments":true,"path":"2020/12/30/spider-get-ajax-and-frame-page/","link":"","permalink":"http://laclic.github.io/2020/12/30/spider-get-ajax-and-frame-page/","excerpt":"","text":"Copyright: LacLic python: 获取 ajax 和 frame 子页面该博客提供的解决思路适用于需要获取子界面情况 事件发生想要爬取该页面的阅读数，审计网页元素后找到了相应信息。 爬取后源代码后发现问题，审计网页源代码，发现没有阅读数的值，只发现了一串urn 解决方案爬取urn，接入url合并为新的uri，打开对应页面，并爬取新的页面源代码，得到所需内容 12345678910111213141516171819def parse_page_content(html): pattern = re.compile( # Regex r&#x27;&lt;div class=&quot;detail_main_content&quot;&gt;\\s.*?&gt;(.*?)&lt;/p&gt;[\\s\\S]*fbsj.*?&gt;([0-9]*)-([0-9]*)-([0-9]*)[\\s\\S]*author.*?&gt;(.*?)&lt;/span&gt;[\\s\\S]*?Count.*?id=([0-9]*)[\\s\\S]*?&lt;strong&gt;(.*?)/&lt;/strong&gt;(.*?)&lt;/div&gt;&#x27;, re.S) # 其中 Count.*?id=([0-9]*) 中 id= 后的部分便是需要的id内容 ↑-----↑ items = re.findall(pattern, html) for item in items: response = requests.get( f&#x27;&quot;&quot;&quot;省略无关url&quot;&quot;&quot;/getDocReadCount.do?id=&#123;item[5]&#125;&#x27;) # &lt;--- 获阅返回读数页面的uri并爬取页面 yield &#123; # convert to dict &#x27;title&#x27;: item[0], &#x27;year&#x27;: item[1], &#x27;month&#x27;: item[2], &#x27;day&#x27;: item[3], &#x27;author&#x27;: item[4], &#x27;read&#x27;: response.text, # &lt;--- 写入到阅读数 &#x27;from&#x27;: item[6], &#x27;content&#x27;: &quot;&quot;&quot;省略无关解析内容的表达式（写太长了，又懒得改，只好掩人耳目了！）&quot;&quot;&quot; &#125; return 0 爬取成功！ 解决过程（使用火狐浏览器）F12打开开发者工具，点开network（网络）发现除了获取了主页面外，还通过POST获取了getDocReadCount的东西，如下图： 通过英文审计，这不就是我们需要的阅读数吗！ 另外看到上面的urn，似曾相识… 123&lt;span id=&quot;readcount&quot;&gt;&lt;/span&gt;&lt;script&gt; $.ajax(&#123;type:&#x27;post&#x27;,url:&#x27;/interFace/getDocReadCount.do?id=509488&#x27;,timeout:2000,success:function(ret)&#123;$(&#x27;#readcount&#x27;).html($.trim(ret))&#125;,error:function(ret)&#123;$.ajax(&#123;type:&#x27;post&#x27;,url:&#x27;/ecms_external?method=syncOfflineVisitCount&#x27;,data:&#x27;type=doc&amp;requestUrl=&#x27;+location.href,timeout:2000,success:function(ret)&#123;$(&#x27;#readcount&#x27;).html(ret);&#125;,error:function()&#123;$(&#x27;#readcount&#x27;).html(0);&#125;&#125;);&#125;&#125;); 这不就是上面看到的 12url:&#x27;/interFace/getDocReadCount.do?id=509488&#x27; 好了，我们只要构造request去获取 ‘(相关url)/interFace/getDocReadCount.do?id=509488’（组成成为一个网址）的页面即可！ 12345id = (&quot;&quot;&quot;已经爬到的id&quot;&quot;&quot;)response = requests.get( f&#x27;http://(相关url)/interFace/getDocReadCount.do?id=&#123;id&#125;&#x27;)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://laclic.github.io/tags/python/"},{"name":"spider","slug":"spider","permalink":"http://laclic.github.io/tags/spider/"}]},{"title":"C语言实现 红黑树 源代码","slug":"RBtree","date":"2020-12-25T08:39:21.000Z","updated":"2020-12-27T07:35:17.150Z","comments":true,"path":"2020/12/25/RBtree/","link":"","permalink":"http://laclic.github.io/2020/12/25/RBtree/","excerpt":"","text":"int 型 红黑树&emsp;采用了双向结构，子节点可指向父节点&emsp;代码采用了多.c文件形式，需要在一个project下进行编译 函数名 英文释义 中文释义 treeCrt() Tree Create 创建树 treeAdd() Tree Add 向树添加节点 treePrt() Tree Print 打印树/输出树 \\ \\ \\ _treeAdd_recur() Tree Add Recursion 通过递归方式查找插入位点并插入 _treeJug() Tree Judge 比较判断节点值的大小关系 _treePrt_recur() Tree Print Recursion 通过递归方式打印树 _treeChk() Tree Check 检查节点附近的情况 _treeRot() Tree Rotate 选择树的结点 _nodeCrt() Node Create 创建并返回一个带值的节点 &emsp;注：开头带下划线的函数表示私有函数（不希望直接被访问，只是为了给非下划线函数使用方便） 头文件： 123456789101112131415161718192021222324252627282930#ifndef _TREE_H_#define _TREE_H_#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct _node&#123; int value; struct _node *p[2]; // p[0]: left-son, p[1]: right-son struct _node *father; char BR; // 0: black; 1: red; &#125;Node;typedef struct _rbtree&#123; Node* head;&#125;RBTree;RBTree treeCrt();void treeAdd(RBTree* t,int value);void treePrt(RBTree t);void _treeAdd_recur(Node* now,const int value);void _treePrt_recur(Node* now,int layer);void _treeChk(Node* now,int son);int _treeJdg(Node* const now,const int value);void _treeRot(Node* now,const int drc); // lift the left or right one to now position, drc means directionNode* _nodeCrt(Node* father,int value);#endif 红黑树 的 创建 与 添加 函数名 英文释义 中文释义 treeCrt() Tree Create 创建树 treeAdd() Tree Add 向树添加节点 _treeAdd_recur() Tree Add Recursion 通过递归方式查找插入位点并插入 _treeJug() Tree Judge 比较判断节点值的大小关系 _nodeCrt() Node Create 创建并返回一个带值的节点 1234567#include &quot;tree.h&quot;RBTree treeCrt() &#123; RBTree t = &#123;NULL&#125;; return t;&#125; 1234567891011121314151617#include &quot;tree.h&quot;void treeAdd(RBTree*t,int value) &#123; // 将添加函数进行了封装，而非直接用主函数来进行递归 if(t-&gt;head) _treeAdd_recur(t-&gt;head,value); else t-&gt;head = _nodeCrt(NULL,value); t-&gt;head-&gt;BR = 0;&#125;void _treeAdd_recur(Node* now,int value) &#123; int drc = _treeJdg(now,value); // drc: direction, left(0) or right(1) // _treeJdg()函数用于判断大小以确定 if(now-&gt;p[drc]) _treeAdd_recur(now-&gt;p[drc],value); else &#123; now-&gt;p[drc] = _nodeCrt(now,value); _treeChk(now,drc); // 用于检查红黑关系的函数 &#125;&#125; 1234#include &quot;tree.h&quot;int _treeJdg(Node* const now,const int value) &#123; return now-&gt;value &lt; value; &#125; 12345678910#include &quot;tree.h&quot;Node* _nodeCrt(Node* father,int value) &#123; Node* node = (Node*) malloc(sizeof(Node)); node-&gt;father = father; node-&gt;p[0] = NULL; node-&gt;p[1] = NULL; node-&gt;value = value; node-&gt;BR = 1;&#125; 红黑树 的 打印/输出/展示&emsp;由于输出的特性，我们无法竖着输出我们所熟悉的二叉树，只能通过递归的方式来横向输出我们的二叉树 函数名 英文释义 中文释义 treePrt() Tree Print 打印树/输出树 _treePrt_recur() Tree Print Recursion 通过递归方式打印树 123456789101112131415#include &quot;tree.h&quot;void treePrt(RBTree t) &#123; // 同样是进行了封装 if(t.head) _treePrt_recur(t.head,0); // 判断空树，如果t上有结点（不是空树）就进入递归 else printf(&quot;This is an empty tree.\\n&quot;); // 否则，输出空树 printf(&quot;------------------------------------\\n&quot;); // 分隔符&#125;void _treePrt_recur(Node* now,int layer) &#123; // layer 代指当前所处的层数/递归的深度 if(now-&gt;p[1]) _treePrt_recur(now-&gt;p[1],layer+1); for(int i=0;i&lt;layer;++i) printf(&quot;\\t&quot;); // 制表符，让格式更好看 printf(&quot;%d(BR-%d)\\n&quot;,now-&gt;value,now-&gt;BR); if(now-&gt;p[0]) _treePrt_recur(now-&gt;p[0],layer+1);&#125; 红黑树 的 检查与旋转 函数名 英文释义 中文释义 _treeChk() Tree Check 检查节点附近的情况 _treeRot() Tree Rotate 选择树的结点 &emsp;检查新插入节点、其父节点，以及其祖父节点（父节点的父节点） 12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;tree.h&quot;void _treeChk(Node* f,int son) &#123; // son of father(f) is the added node int status = 0b00; // if (son &gt; f) ==&gt; 0b1??, son &gt; gf ==&gt; 0b?1? Node* gf = f-&gt;father; Node* s; // s means son, Node* if(gf&amp;&amp;f-&gt;BR) &#123; if(gf-&gt;p[0]&amp;&amp;gf-&gt;p[1]&amp;&amp;gf-&gt;p[0]-&gt;BR&amp;&amp;gf-&gt;p[1]-&gt;BR) &#123; // left-son and right-son exists, left and right sons are both red gf-&gt;BR = 1; gf-&gt;p[0]-&gt;BR = 0; gf-&gt;p[1]-&gt;BR = 0; if(gf-&gt;father) &#123; _treeChk(gf-&gt;father,gf-&gt;value &gt; gf-&gt;father-&gt;value); &#125; &#125;else &#123; status = son; s = f-&gt;p[son]; // s means son of f, Node* status = (status &lt;&lt; 1) + (f-&gt;p[son]-&gt;value &gt; gf-&gt;value); switch(status) &#123; case 0b00 : ; case 0b11 : f-&gt;BR = 1; gf-&gt;BR = 0; _treeRot(gf,!(1&amp;status)); break; case 0b10 : ; case 0b01 : f-&gt;BR = 1; gf-&gt;BR = 0; _treeRot(f,!son); _treeRot(gf,!(1&amp;status)); break; default : ; &#125; &#125; &#125; return;&#125; &emsp;以下函数中的drc，0代表左旋，1代表右旋 12345678910111213#include &quot;tree.h&quot;void _treeRot(Node* now,const int drc) &#123; // left-rotate: 0 now-&gt;value ^= now-&gt;p[!drc]-&gt;value ^= now-&gt;value ^= now-&gt;p[!drc]-&gt;value; // swap value Node* temp = now-&gt;p[drc]; now-&gt;p[drc] = now-&gt;p[!drc]; now-&gt;p[!drc] = now-&gt;p[drc]-&gt;p[!drc]; now-&gt;p[drc]-&gt;p[!drc] = now-&gt;p[drc]-&gt;p[drc]; now-&gt;p[drc]-&gt;p[drc] = temp; if(temp) temp-&gt;father = now-&gt;p[drc]; if(now-&gt;p[!drc]) now-&gt;p[!drc]-&gt;father = now;&#125;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://laclic.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"http://laclic.github.io/tags/data-structure/"}]},{"title":"P1980 最优解（30ms）","slug":"P1980","date":"2020-12-24T05:07:50.000Z","updated":"2020-12-24T05:14:48.009Z","comments":true,"path":"2020/12/24/P1980/","link":"","permalink":"http://laclic.github.io/2020/12/24/P1980/","excerpt":"","text":"Copyright LacLic 思路每一位 = 去尾数据 + 此位值 * 此位后的输入 显然，需要重点考虑0出现的次数 举例记 输入为 26759，（不考虑x，直接把0~9全都算出来，最后再输出） 记 答案数组 为 A[0~9](26759)（10长度的数组） &emsp;其中，A是长度为10的数组，用以表示数字出现的次数，0~9表示0到9每一位，括号内表示输入 A[09](26759) = A[09](20000) + A[2](6759) A[09](6759) = A[09](6000) + A[6](759) A[09](759) = A[09](700) + A[7](59) A[09](59) = A[09](50) + A[5](9) A[09](759) = A[09](9) + A[9](0) A[9](0) = 0A[0~9] = {1,1,1,1,1,1,1,1,1,1} 此处考虑到方便，就先记0处为1，后续进行删除 最终代码（虽然用的是c++，但是完全用的是c的语法，30ms） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// copyright LacLic#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define BITS 8#define NUM 10unsigned long long storage[BITS] = &#123;1,20,300,4000,50000,600000,7000000,80000000&#125;;unsigned long long a[NUM] = &#123;0&#125;;inline int intPow(int base,int power) &#123; int ret = 1; for(;power;--power) &#123; ret *= base; &#125; return ret;&#125;int main(int argc, char const *argv[])&#123; int b[BITS]; // 10 000 000 int n,x,height; int LEN; // means the total bits-1 scanf(&quot;%d %d&quot;,&amp;n,&amp;x); ++n; // 这句只是因为发现最后算出来的数据会不到n，所以++后刚刚好 int N = n; for(LEN=0;1;++LEN) &#123; b[LEN] = n%10; n /= 10; if(!n) break; &#125; height = intPow(10,LEN); for(int i=LEN;i&gt;=0;--i) &#123; int numOfBit = intPow(NUM,i); for(int j=0;j&lt;b[i];++j) &#123; a[j] += numOfBit; for(int k=0;k&lt;NUM;++k) &#123; a[k] += storage[i-1]; &#125; &#125; a[b[i]] += N % numOfBit; &#125; for(;height;height/=10) &#123; // 发现0处有问题，所以添加这段来修正a[0] a[0] -= height; &#125; printf(&quot;%d&quot;,a[x]); return 0;&#125;// 30ms 普通递归算法(129ms) 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int a[10] = &#123;0&#125;;void count(int now) &#123; for(;now;now/=10) &#123; ++a[now%10]; &#125; return;&#125;int main(int argc, char const *argv[])&#123; int N,x; scanf(&quot;%d %d&quot;,&amp;N,&amp;x); for(int i=1;i&lt;=N;++i) &#123; count(i); &#125; // for(int i=0;i&lt;10;++i) &#123; // printf(&quot;a[%d] = %d\\n&quot;,i,a[i]); // &#125; printf(&quot;%d&quot;,a[x]); return 0;&#125;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://laclic.github.io/tags/algorithm/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://laclic.github.io/tags/Leetcode/"}]},{"title":"Flutter autovalidate is deprecated","slug":"Flutter-autovalidate-is-deprecated","date":"2020-11-25T15:07:20.000Z","updated":"2020-12-03T10:09:26.969Z","comments":true,"path":"2020/11/25/Flutter-autovalidate-is-deprecated/","link":"","permalink":"http://laclic.github.io/2020/11/25/Flutter-autovalidate-is-deprecated/","excerpt":"","text":"Flutter Deprecated:&emsp;‘autovalidate’ is deprecated and shouldn’t be used.Created by: © LacLic 事件发生&emsp;在表单 (FormField) 中调用 autovalidate (自动生效)参数时，发生了如下现象（在 vscode 中）： autovalidate形式参数被划上了删除线 vscode提供了相应的提示信息（如下 / 如图） &emsp;Used to enable/disable form fields auto validation and update their error text. &emsp;autovalidate参数 曾用于启用 / 停用表单的 自动生效并更新他们的错误文本（错误文本大概是”密码应不少于6位”的提示文本） &emsp;’autovalidate’ is deprecated and shouldn’t be used. Use autoValidateMode parameter which provides more specific behavior related to auto validation. This feature was deprecated after v1.19.0.. &emsp;autovalidate参数 已经被逐步弃用。试着用用能提供更具体化的 autoValidateMode参数 来进行代替 autovalidate 功能。这个功能（原本的autovalidate参数）在版本1.19.0开始已经被弃用了。 Try replacing the use of the deprecated member with the replacement. &emsp;去用 autovalidateMode 参数吧 &emsp;flutter 中文网上的教程并没有关于这方面的阐述说明，以下资料参考自 StackoverFlow 等网站. 解决方案 &emsp;All you need to do is replace autovalidate: true with autovalidateMode: AutovalidateMode.always &emsp;翻译：把 autovalidate: true 换成 autovalidateMode: AutovalidateMode.always即可 例： 12345child: Form( key: _formKey, autovalidate: true, // &lt;- here child: null,), 12345child: Form( key: _formKey, autovalidateMode: AutovalidateMode.always, // &lt;- here child: null,), 关于 autovalidateMode The different supported modes are: AutovalidateMode.disabled: No auto validation will occur.· 表单不会自动更新 AutovalidateMode.always: Used to auto-validate FormField even without user interaction.· 实时更新表单 AutovalidateMode.onUserInteraction: Used to auto-validate FormField only after each user interaction.· 只有在用户交互后，才会更新表单","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://laclic.github.io/tags/Flutter/"},{"name":"Deprecation","slug":"Deprecation","permalink":"http://laclic.github.io/tags/Deprecation/"}]},{"title":"Flutter_Exception_multiple_heroes","slug":"Flutter-Exception-multiple-heroes","date":"2020-11-16T14:31:23.000Z","updated":"2020-12-03T10:09:37.408Z","comments":true,"path":"2020/11/16/Flutter-Exception-multiple-heroes/","link":"","permalink":"http://laclic.github.io/2020/11/16/Flutter-Exception-multiple-heroes/","excerpt":"","text":"Flutter Exception： &emsp;There are multiple heroes that share the same tag within a subtreeCreated by: © LacLic 错误发生&emsp;这个异常(exception)主要出现于一个页面/路由(route)中有两个及以上的浮标按钮(FloatingActionButtom)。 &emsp;以下是异常报错代码及状况：*仅展示了部分代码* 123456789101112131415161718192021222324252627282930class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;// ...省略无关代码@overrideWidget build(BuildContext context) &#123; return Scaffold( appBar: /* ...省略无关代码 */, body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ /*...省略无关widget代码 */ FloatingActionButton( onPressed: () =&gt; Navigator.pushNamed(context, &quot;test_form&quot;), child: Icon(Icons.plus_one), ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: () &#123; Navigator.pushNamed(context, &quot;test_theme&quot;); _decrementCounter(); &#125;, tooltip: &#x27;new page&#x27;, child: Icon(Icons.home), ), );&#125; &emsp;会出现如图所示的异常(exception) 解决方案&emsp;只需要向各个浮标按钮的heroTag参数传入一个与其它浮标按钮不同的值（字符串）即可： 1234567FloatingActionButton( onPressed: () =&gt; Navigator.pushNamed(context, &quot;test_form&quot;), child: Icon(Icons.plus_one), heroTag: &#x27;example&#x27;, // &lt;- here), 里面的example可以替换成任意你想输入的值，只要不与其它的浮标按钮(FloatingActionButtom)的heroTag值相同即可 错误原理&emsp;首先得知道Hero是Flutter中的一种动画形式，两个带有同样hero标识的元素在页面切换时会有一个飞动的效果，该效果由flutter自动实现。该标识对应的属性名为heroTag，在同一个页面内，每个heroTag只能拥有一个独一无二的值（和 html 中的 id 一样），如果重复就会抛出标题所示的异常 ‘There are multiple heroes that share the same tag within a subtree.’ [^REF] &emsp;Flutter 相应部分源码： 1234567const FloatingActionButton(&#123; //省略无关参数 this.heroTag = const _DefaultHeroTag(), //省略无关参数&#125;) 其中： 1234567class _DefaultHeroTag &#123; const _DefaultHeroTag(); @override String toString() =&gt; &#x27;&lt;default FloatingActionButton tag&gt;&#x27;;&#125; &emsp;明显看出，heroTag会被默认初始化为 ‘&lt;default FloatingActionButton tag&gt;‘ ，导致未向heroTag传入参数的地方，全都默认为上面那段字符串 1234567final Object heroTag;/// The callback that is called when the button is tapped or otherwise activated.////// If this is set to null, the button will be disabled. &emsp;就是说这个参数是用来管理这个按钮的点击等事件的，如果多个按钮使用同一个heroTag则会触发联动，造成问题，为了防止问题，flutter提前进行了异常报错 [^REF]: CSDN id: in_motion 的博客.","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://laclic.github.io/tags/Flutter/"},{"name":"Exception","slug":"Exception","permalink":"http://laclic.github.io/tags/Exception/"}]},{"title":"my-first-blog","slug":"my-first-blog","date":"2020-11-07T12:11:54.000Z","updated":"2020-12-03T10:07:27.701Z","comments":true,"path":"2020/11/07/my-first-blog/","link":"","permalink":"http://laclic.github.io/2020/11/07/my-first-blog/","excerpt":"","text":"Make it great!","categories":[],"tags":[{"name":"Default","slug":"Default","permalink":"http://laclic.github.io/tags/Default/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-07T08:26:14.862Z","updated":"2020-11-07T08:26:14.862Z","comments":true,"path":"2020/11/07/hello-world/","link":"","permalink":"http://laclic.github.io/2020/11/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://laclic.github.io/tags/codeforces/"},{"name":"sort","slug":"sort","permalink":"http://laclic.github.io/tags/sort/"},{"name":"string","slug":"string","permalink":"http://laclic.github.io/tags/string/"},{"name":"existence problem","slug":"existence-problem","permalink":"http://laclic.github.io/tags/existence-problem/"},{"name":"FZUACM","slug":"FZUACM","permalink":"http://laclic.github.io/tags/FZUACM/"},{"name":"search","slug":"search","permalink":"http://laclic.github.io/tags/search/"},{"name":"brute force","slug":"brute-force","permalink":"http://laclic.github.io/tags/brute-force/"},{"name":"format","slug":"format","permalink":"http://laclic.github.io/tags/format/"},{"name":"linux","slug":"linux","permalink":"http://laclic.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://laclic.github.io/tags/ubuntu/"},{"name":"shell","slug":"shell","permalink":"http://laclic.github.io/tags/shell/"},{"name":"vnt-chain","slug":"vnt-chain","permalink":"http://laclic.github.io/tags/vnt-chain/"},{"name":"block chain","slug":"block-chain","permalink":"http://laclic.github.io/tags/block-chain/"},{"name":"linked list","slug":"linked-list","permalink":"http://laclic.github.io/tags/linked-list/"},{"name":"array list","slug":"array-list","permalink":"http://laclic.github.io/tags/array-list/"},{"name":"wsl","slug":"wsl","permalink":"http://laclic.github.io/tags/wsl/"},{"name":"c++","slug":"c","permalink":"http://laclic.github.io/tags/c/"},{"name":"stack","slug":"stack","permalink":"http://laclic.github.io/tags/stack/"},{"name":"priority_queue","slug":"priority-queue","permalink":"http://laclic.github.io/tags/priority-queue/"},{"name":"string and point","slug":"string-and-point","permalink":"http://laclic.github.io/tags/string-and-point/"},{"name":"deque","slug":"deque","permalink":"http://laclic.github.io/tags/deque/"},{"name":"circle","slug":"circle","permalink":"http://laclic.github.io/tags/circle/"},{"name":"python","slug":"python","permalink":"http://laclic.github.io/tags/python/"},{"name":"spider","slug":"spider","permalink":"http://laclic.github.io/tags/spider/"},{"name":"algorithm","slug":"algorithm","permalink":"http://laclic.github.io/tags/algorithm/"},{"name":"data structure","slug":"data-structure","permalink":"http://laclic.github.io/tags/data-structure/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://laclic.github.io/tags/Leetcode/"},{"name":"Flutter","slug":"Flutter","permalink":"http://laclic.github.io/tags/Flutter/"},{"name":"Deprecation","slug":"Deprecation","permalink":"http://laclic.github.io/tags/Deprecation/"},{"name":"Exception","slug":"Exception","permalink":"http://laclic.github.io/tags/Exception/"},{"name":"Default","slug":"Default","permalink":"http://laclic.github.io/tags/Default/"}]}